<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ydderf&#39;s blog</title>
    <link>https://blog.ydderf.dev/posts/</link>
    <description>Recent content in Posts on ydderf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 06 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.ydderf.dev/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Arch Linux Installation</title>
      <link>https://blog.ydderf.dev/posts/arch-linux-installation/</link>
      <pubDate>Mon, 06 Jan 2025 00:00:00 +0000</pubDate>
      
      <guid>https://blog.ydderf.dev/posts/arch-linux-installation/</guid>
      <description>&lt;h1 id=&#34;arch-linux-installation&#34;&gt;Arch Linux Installation&lt;/h1&gt;
&lt;h5 id=&#34;install-targets&#34;&gt;install targets&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;base&lt;/li&gt;
&lt;li&gt;linux&lt;/li&gt;
&lt;li&gt;linux-firmware&lt;/li&gt;
&lt;li&gt;vim (for editing files)&lt;/li&gt;
&lt;li&gt;man-db (for man pages)&lt;/li&gt;
&lt;li&gt;man-pages&lt;/li&gt;
&lt;li&gt;dhcpcd&lt;/li&gt;
&lt;li&gt;amd-ucode / intel-ucode ([[microcode]])&lt;/li&gt;
&lt;li&gt;lvm2 (for lvm partitions)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;optional&#34;&gt;optional&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;base-devel&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;if &lt;code&gt;dhcpcd&lt;/code&gt; is not installed, and arch is installed in an emulated environment
the newly installed operating system would not have network access
to get the network access back, the iso file that installed the operating system is needed&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;use &lt;code&gt;fdisk -l&lt;/code&gt; to identify the &lt;code&gt;root partition&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;use &lt;code&gt;mount /dev/sda3 /mnt&lt;/code&gt; to mount the &lt;code&gt;root partition&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;(assuming the root partition is in &lt;code&gt;/dev/sda3&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;use mount &lt;code&gt;/dev/sda1 /mnt/boot&lt;/code&gt; to mount the &lt;code&gt;boot partition&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;(assuming the boot partition is int `/dev/sda1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;swap on any swap partition if any exist using &lt;code&gt;swapon /dev/sda2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;use &lt;code&gt;arch-chroot /mnt&lt;/code&gt; into the system&lt;/li&gt;
&lt;li&gt;install the missing services using &lt;code&gt;pacman -S &amp;lt;target&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;</description>
      <content>&lt;h1 id=&#34;arch-linux-installation&#34;&gt;Arch Linux Installation&lt;/h1&gt;
&lt;h5 id=&#34;install-targets&#34;&gt;install targets&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;base&lt;/li&gt;
&lt;li&gt;linux&lt;/li&gt;
&lt;li&gt;linux-firmware&lt;/li&gt;
&lt;li&gt;vim (for editing files)&lt;/li&gt;
&lt;li&gt;man-db (for man pages)&lt;/li&gt;
&lt;li&gt;man-pages&lt;/li&gt;
&lt;li&gt;dhcpcd&lt;/li&gt;
&lt;li&gt;amd-ucode / intel-ucode ([[microcode]])&lt;/li&gt;
&lt;li&gt;lvm2 (for lvm partitions)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;optional&#34;&gt;optional&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;base-devel&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;if &lt;code&gt;dhcpcd&lt;/code&gt; is not installed, and arch is installed in an emulated environment
the newly installed operating system would not have network access
to get the network access back, the iso file that installed the operating system is needed&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;use &lt;code&gt;fdisk -l&lt;/code&gt; to identify the &lt;code&gt;root partition&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;use &lt;code&gt;mount /dev/sda3 /mnt&lt;/code&gt; to mount the &lt;code&gt;root partition&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;(assuming the root partition is in &lt;code&gt;/dev/sda3&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;use mount &lt;code&gt;/dev/sda1 /mnt/boot&lt;/code&gt; to mount the &lt;code&gt;boot partition&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;(assuming the boot partition is int `/dev/sda1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;swap on any swap partition if any exist using &lt;code&gt;swapon /dev/sda2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;use &lt;code&gt;arch-chroot /mnt&lt;/code&gt; into the system&lt;/li&gt;
&lt;li&gt;install the missing services using &lt;code&gt;pacman -S &amp;lt;target&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;
</content>
    </item>
    
    <item>
      <title>Windows DLL</title>
      <link>https://blog.ydderf.dev/posts/windows-dll/</link>
      <pubDate>Mon, 06 Jan 2025 00:00:00 +0000</pubDate>
      
      <guid>https://blog.ydderf.dev/posts/windows-dll/</guid>
      <description>&lt;h1 id=&#34;windows-dll&#34;&gt;Windows DLL&lt;/h1&gt;
&lt;p&gt;DLL is a shared library that is a module that cannot be executed directly, but needs to be loaded to use the exported functions.&lt;/p&gt;
&lt;h3 id=&#34;system-wide-dll-base-address&#34;&gt;System-wide DLL Base Address&lt;/h3&gt;
&lt;p&gt;For optimization purposes, some DLLs are loaded at the same base address in the virtual space of all processes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ydderf.dev/images/systemwidedll.png&#34; alt=&#34;Image Description&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;dll-entry-point&#34;&gt;DLL Entry Point&lt;/h3&gt;
&lt;p&gt;Since DLLs are loaded by executables, they can specify an entry point function that executes code when certain actions occur.&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;windows-dll&#34;&gt;Windows DLL&lt;/h1&gt;
&lt;p&gt;DLL is a shared library that is a module that cannot be executed directly, but needs to be loaded to use the exported functions.&lt;/p&gt;
&lt;h3 id=&#34;system-wide-dll-base-address&#34;&gt;System-wide DLL Base Address&lt;/h3&gt;
&lt;p&gt;For optimization purposes, some DLLs are loaded at the same base address in the virtual space of all processes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ydderf.dev/images/systemwidedll.png&#34; alt=&#34;Image Description&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;dll-entry-point&#34;&gt;DLL Entry Point&lt;/h3&gt;
&lt;p&gt;Since DLLs are loaded by executables, they can specify an entry point function that executes code when certain actions occur.&lt;/p&gt;
&lt;p&gt;There are 4 possibilities for the entry point being called:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DLL_PROCESS_ATTACH&lt;/code&gt; - a process is loading the DLL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DLL_THREAD_ATTACH&lt;/code&gt; - a process is creating a new thread&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DLL_THREAD_DETACH&lt;/code&gt; - a thread exits normally&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DLL_PROCESS_DETACH&lt;/code&gt; - a process unloads the DLL&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;exporting-a-function&#34;&gt;Exporting a Function&lt;/h3&gt;
&lt;p&gt;To export a function in a DLL, it must be declared by keywords &lt;code&gt;extern&lt;/code&gt; and &lt;code&gt;__declspec(dllexport)&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__declspec&lt;/span&gt;(dllexport) &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Hello&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;MessageBoxA&lt;/span&gt;(NULL, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;message&amp;#34;&lt;/span&gt;, MB_ICONINFORMATION);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;the function &lt;code&gt;Hello()&lt;/code&gt; can be called after the dll is loaded into memory&lt;/p&gt;
&lt;h3 id=&#34;dynamic-linking&#34;&gt;Dynamic Linking&lt;/h3&gt;
&lt;p&gt;Functions can be imported using &lt;code&gt;LoadLibrary&lt;/code&gt;, &lt;code&gt;GetModuleHandle&lt;/code&gt;, and &lt;code&gt;GetProcAddress&lt;/code&gt;.&lt;/p&gt;
&lt;h5 id=&#34;step-1---loading-a-dll&#34;&gt;Step 1 - Loading a DLL&lt;/h5&gt;
&lt;p&gt;The calling of Windows functions will make the process load the required DLLs in the beginning.&lt;/p&gt;
&lt;p&gt;Custom DLLs must be loaded manually with the functions mentioned before.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	HMODULE hModule &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LoadLibraryA&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Dll1.dll&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;step-2---retrieving-a-dlls-handle&#34;&gt;Step 2 - Retrieving a DLL&amp;rsquo;s Handle&lt;/h5&gt;
&lt;p&gt;If the target DLL had been loaded into the memory, the handle can be retrieved via &lt;code&gt;GetModuleHandleA&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	HMODULE hModule &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GetModuleHandleA&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Dll1.dll&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// if the dll has not been loaded
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (hModule &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		hModule &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LoadLibraryA&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Dll1.dll&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;step-3---retrieving-a-functions-address&#34;&gt;Step 3 - Retrieving a Function&amp;rsquo;s Address&lt;/h5&gt;
&lt;p&gt;After the DLL is loaded and the handle is retrieved, the target function&amp;rsquo;s address must be located.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	HMODULE hModule &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GetModuleHandleA&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Dll1.dll&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (hModule &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		hModule &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LoadLibraryA&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Dll1.dll&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// pHelloWorld now stores the function&amp;#39;s address
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	PVOID pHelloWorld &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GetProcessAddress&lt;/span&gt;(hModule, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;HelloWorld&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;step-4---type-casting-the-functions-address&#34;&gt;Step 4 - Type-casting The Function&amp;rsquo;s Address&lt;/h5&gt;
&lt;p&gt;The type-casting to the function pointer is required in order to conveniently invoke the function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; (WINAPI&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; HelloWorldfptr)();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	HMODULE hModule &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GetModuleHandleA&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sampleDLL.dll&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (hModule &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// If the DLL is not loaded in memory, use LoadLibrary to load it
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        hModule &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LoadLibraryA&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sampleDLL.dll&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    PVOID pHelloWorld &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GetProcAddress&lt;/span&gt;(hModule, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;HelloWorld&amp;#34;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/// pHelloWorld stores HelloWorld&amp;#39;s function address
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    HelloWorldFunctionPointer HelloWorld &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (HelloWorldFunctionPointer)pHelloWorld;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;putting-it-together&#34;&gt;Putting it Together&lt;/h3&gt;
&lt;p&gt;Another example for calling MessageBoxA.
The following assumes that &lt;code&gt;user32.dll&lt;/code&gt; is not automatically loaded into the memory&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; (WINAPI&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; MessageBoxAFunctionPointer)(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	HWND    hWnd,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	LPCSTR  lpText,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	LPCSTR  lpCaption,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	UINT    uType
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	MessageBoxAFunctionPointer pMessageBoxA &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (MessageBoxAFunctionPointer)&lt;span style=&#34;color:#a6e22e&#34;&gt;GetProcessAddress&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;LoadLibraryA&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user32.dll&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MessageBoxA&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (pMessageBoxA &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; NULL) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;pMessageBoxA&lt;/span&gt;(NULL, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;caption&amp;#34;&lt;/span&gt;, MB_OK);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;running-dlls-directly&#34;&gt;Running DLLs Directly&lt;/h3&gt;
&lt;p&gt;Another way to run the functions in a DLL is by &lt;code&gt;rundll32.exe&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rundll32.exe &amp;lt;dllname&amp;gt;,&amp;lt;target &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The following example locks the machine via the function &lt;code&gt;LockWorkStation&lt;/code&gt; in &lt;code&gt;user32.dll&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rundll32.exe user32.dll,LockWorkStation
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </item>
    
    <item>
      <title>Windows Process</title>
      <link>https://blog.ydderf.dev/posts/windows-process/</link>
      <pubDate>Mon, 06 Jan 2025 00:00:00 +0000</pubDate>
      
      <guid>https://blog.ydderf.dev/posts/windows-process/</guid>
      <description>&lt;h1 id=&#34;windows-process&#34;&gt;Windows Process&lt;/h1&gt;
&lt;h3 id=&#34;memory-types&#34;&gt;Memory Types&lt;/h3&gt;
&lt;p&gt;A process can have 3 different types of memory&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Private memory&lt;/code&gt; - dedicated to a single process, not shared by other processes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mapped memory&lt;/code&gt; - can be shared between multiple processes, examples: shared libraries, shared memory segments, and shared files.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Image memory&lt;/code&gt; - contains code and data of an executable file. used to store the code and data that is used by the process. often related to ==DLL files== loaded into a process&amp;rsquo;s address space.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;process-environment-block-peb&#34;&gt;Process Environment Block (PEB)&lt;/h3&gt;
&lt;p&gt;Contains information about a process, such as its&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;windows-process&#34;&gt;Windows Process&lt;/h1&gt;
&lt;h3 id=&#34;memory-types&#34;&gt;Memory Types&lt;/h3&gt;
&lt;p&gt;A process can have 3 different types of memory&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Private memory&lt;/code&gt; - dedicated to a single process, not shared by other processes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mapped memory&lt;/code&gt; - can be shared between multiple processes, examples: shared libraries, shared memory segments, and shared files.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Image memory&lt;/code&gt; - contains code and data of an executable file. used to store the code and data that is used by the process. often related to ==DLL files== loaded into a process&amp;rsquo;s address space.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;process-environment-block-peb&#34;&gt;Process Environment Block (PEB)&lt;/h3&gt;
&lt;p&gt;Contains information about a process, such as its&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parameters&lt;/li&gt;
&lt;li&gt;Startup information&lt;/li&gt;
&lt;li&gt;Allocated heap&lt;/li&gt;
&lt;li&gt;Loaded DLLs&lt;/li&gt;
&lt;li&gt;Process ID&lt;/li&gt;
&lt;li&gt;Path to the executable&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Used by the operating system to store information about the process, and by the Windows loader to launch applications.&lt;/p&gt;
&lt;h5 id=&#34;peb-structure&#34;&gt;PEB Structure&lt;/h5&gt;
&lt;p&gt;Important members are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[[#BeingDebugged]]&lt;/li&gt;
&lt;li&gt;[[#Ldr]]&lt;/li&gt;
&lt;li&gt;[[#ProcessParameters]]&lt;/li&gt;
&lt;li&gt;[[#AtlThunkSListPtr &amp;amp; AtlThunkSListPtr32]]&lt;/li&gt;
&lt;li&gt;[[#PostProcessInitRoutine]]&lt;/li&gt;
&lt;li&gt;[[#SessionId]]&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; _PEB {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  BYTE                          Reserved1[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  BYTE                          BeingDebugged;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  BYTE                          Reserved2[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID                         Reserved3[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PPEB_LDR_DATA                 Ldr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID                         Reserved4[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID                         AtlThunkSListPtr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID                         Reserved5;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ULONG                         Reserved6;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID                         Reserved7;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ULONG                         Reserved8;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ULONG                         AtlThunkSListPtr32;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID                         Reserved9[&lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  BYTE                          Reserved10[&lt;span style=&#34;color:#ae81ff&#34;&gt;96&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  BYTE                          Reserved11[&lt;span style=&#34;color:#ae81ff&#34;&gt;128&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID                         Reserved12[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ULONG                         SessionId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} PEB, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;PPEB;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;beingdebugged&#34;&gt;BeingDebugged&lt;/h5&gt;
&lt;p&gt;Set to 1 if the process is being debugged.&lt;/p&gt;
&lt;p&gt;Used by the Windows loader to determine whether to launch the application with a debugger attached or not.&lt;/p&gt;
&lt;h5 id=&#34;ldr&#34;&gt;Ldr&lt;/h5&gt;
&lt;p&gt;A pointer to a &lt;code&gt;PEB_LDR_DATA&lt;/code&gt; structure in the &lt;code&gt;PEB&lt;/code&gt;
The structure contains information about the process&amp;rsquo;s loaded dynamic link library modules.&lt;/p&gt;
&lt;p&gt;It includes a list of DLLs loaded in the process, which is used by the Windows loader to keep track of DLLs loaded in the process.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; _PEB_LDR_DATA {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  BYTE       Reserved1[&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID      Reserved2[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  LIST_ENTRY InMemoryOrderModuleList;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} PEB_LDR_DATA, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;PPEB_LDR_DATA;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-ad-tip&#34; data-lang=&#34;ad-tip&#34;&gt;`Ldr` can be leveraged to find the base address of a particular DLL, which can be used to build a ==custom version of GetModuleHandleA/W== to stay stealthy
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;processparameters&#34;&gt;ProcessParameters&lt;/h5&gt;
&lt;p&gt;A pointer to the &lt;code&gt;PTL_USER_PROCESS_PARAMETERS&lt;/code&gt; structure.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; _RTL_USER_PROCESS_PARAMETERS {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  BYTE           Reserved1[&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID          Reserved2[&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  UNICODE_STRING ImagePathName;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  UNICODE_STRING CommandLine;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} RTL_USER_PROCESS_PARAMETERS, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;PRTL_USER_PROCESS_PARAMETERS;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Contains command lines parameters passed to the process when created.&lt;/p&gt;
&lt;p&gt;The parameters are added to the PEB by the Windows loader.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-ad-tip&#34; data-lang=&#34;ad-tip&#34;&gt;`ProcessParameters` can be leveraged to perform ==command line spoofing==
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;atlthunkslistptr--atlthunkslistptr32&#34;&gt;AtlThunkSListPtr &amp;amp; AtlThunkSListPtr32&lt;/h5&gt;
&lt;p&gt;Used by the ATL (Active Template Library) to store a pointer to a linked list of thunking functions.&lt;/p&gt;
&lt;p&gt;Thunking functions are used to call functions that are implemented in a different address space, often represent functions exported from a DLL&lt;/p&gt;
&lt;h5 id=&#34;postprocessinitroutine&#34;&gt;PostProcessInitRoutine&lt;/h5&gt;
&lt;p&gt;Used to store a pointer to a function called by the operating system after TLS (Thread Local Storage) initialization has been completed for all threads in the process.&lt;/p&gt;
&lt;p&gt;This function can also be used to perform additional initialization tasks required by the process.&lt;/p&gt;
&lt;h5 id=&#34;sessionid&#34;&gt;SessionId&lt;/h5&gt;
&lt;p&gt;A identifier of a single session used for tracking the activity of the user during the session.&lt;/p&gt;
&lt;h3 id=&#34;teb-structure&#34;&gt;TEB Structure&lt;/h3&gt;
&lt;p&gt;The import members in TEB&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[[#Process Environment Block (PEB)]]&lt;/li&gt;
&lt;li&gt;[[#TlsSlots]]&lt;/li&gt;
&lt;li&gt;[[#TlsExpansionSlots]]&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; _TEB {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID Reserved1[&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PPEB  ProcessEnvironmentBlock;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID Reserved2[&lt;span style=&#34;color:#ae81ff&#34;&gt;399&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  BYTE  Reserved3[&lt;span style=&#34;color:#ae81ff&#34;&gt;1952&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID TlsSlots[&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  BYTE  Reserved4[&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID Reserved5[&lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID ReservedForOle;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID Reserved6[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PVOID TlsExpansionSlots;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} TEB, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;PTEB;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;processenvironmentblock&#34;&gt;ProcessEnvironmentBlock&lt;/h5&gt;
&lt;p&gt;PEB as described above, stores information about the currently running process.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-ad-note&#34; data-lang=&#34;ad-note&#34;&gt;Processes stands at a higher level in the hierarchy than threads.  
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;tlsslots&#34;&gt;TlsSlots&lt;/h5&gt;
&lt;p&gt;Thread local storage is used to store thread-specific data. Each thread has its own TEB with a set of TLS slots.&lt;/p&gt;
&lt;p&gt;Thread-specific variables, thread-specific handles, and thread-specific states may be stored in the TLS slot.&lt;/p&gt;
&lt;h5 id=&#34;tlsexpansionslots&#34;&gt;TlsExpansionSlots&lt;/h5&gt;
&lt;p&gt;The expansion slots are a set of pointers used to store thread-local storage data for a thread. often reserved for use by system DLLs.&lt;/p&gt;
&lt;h3 id=&#34;process--thread-handles&#34;&gt;Process / Thread Handles&lt;/h3&gt;
&lt;p&gt;Each process / thread has its own unique identifier. One can use these identifiers to get the handle of a process or a thread by &lt;code&gt;OpenProcess&lt;/code&gt; or &lt;code&gt;OpenThread&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-ad-note&#34; data-lang=&#34;ad-note&#34;&gt;To avoid handle-leaking, every opened handle should be closed by `CloseHandle` once their use is no longer required.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;
</content>
    </item>
    
  </channel>
</rss>
